from typing import Tuple, Union
import threading
from pathlib import Path

import numpy as np

from crs.geocrs import GeoCRS
from geopandas import GeoSeries, GeoDataFrame

from ..spacedescriptors.georect import GeoRect


class GeoRaster(GeoRect):

    def __init__(self, georect: GeoRect, data: np.ndarray):
        self.georect = georect
        self.data = data

    @property
    def crs(self) -> GeoCRS:
        return self.georect.crs

    # TODO: might not be pixelaccurate
    def project_into_other(self, other: 'GeoRaster', no_data_value: float = None):
        assert self.data.shape[2] == other.data.shape[2]
        assert self.data.dtype == other.data.dtype
        if self.crs != other.crs:
            raise AttributeError("Both gerasters need to share the same crs.")
        other_pts = np.array([[other.raster_height - 1, 0], [other.raster_height - 1, other.raster_width - 1],
                             [0, other.raster_width - 1], [0, 0]])
        self_pts = self.world_to_rect_relative(other.get_corners())
        self_pts = [((1 - p[1]) * (self.raster_height-1), p[0] * (self.raster_width-1)) for p in self_pts]
        self_pts = np.array(self_pts)
        # TODO: make this faster by directly use the already existing tranformations of the georects instead of reestimating them
        projection = estimate_transform('projective', other_pts, self_pts)
        # warp seems to be very memory hungry so we are using np magic now. Maybe thinkg about a faster way in the future
        # extracted = warp(self.raster_data, projection, output_shape=(other.raster_height, other.raster_width),
        #                 cval=no_data_value, order=0)
        x = np.arange(other.raster_width)
        y = np.arange(other.raster_height)
        other_coords = np.stack(np.meshgrid(y, x))
        other_coords = np.transpose(other_coords.reshape(2, -1), (1, 0))
        self_coords = np.round(projection(other_coords)).astype(int)
        self_coords_mask = ((self_coords[:, 0] < self.raster_height) & (self_coords[:, 0] >= 0) &
                            (self_coords[:, 1] < self.raster_width) & (self_coords[:, 1] >= 0))
        if no_data_value is not None:
            mask = (other.raster_data == no_data_value)
            if len(mask.shape) > 2:
                mask = mask.all(axis=len(mask.shape) - 1)
            mask = mask.reshape(-1, order='F') # THE 'F' IS IMPORTANT HERE TO NOT SCREW UP THE INDEXING ORDER !!!
            mask = mask & self_coords_mask
        else:
            mask = self_coords_mask
        other_coords = other_coords[mask]
        self_coords = self_coords[mask]
        if other.is_thread_safe:
            other._lock.acquire()
        other.raster_data[other_coords[:,0], other_coords[:, 1]] = self.raster_data[self_coords[:, 0], self_coords[:, 1]]
        if other.is_thread_safe:
            other._lock.release()
        other.set_changed()

    def rasterize_shapes(self, shapes: Union[GeoSeries, GeoDataFrame], pixel_value=1, buffer=0):
        if shapes.size == 0:
            return
        shapes = shapes.to_crs(self.crs)
        if isinstance(shapes, GeoDataFrame):
            shapes = shapes['geometry']
        if buffer != 0:
            shapes = shapes.buffer(buffer)
        dst_pts = np.array([[0, self.raster_height - 1], [self.raster_width - 1, self.raster_height - 1],
                            [self.raster_width - 1, 0], [0, 0]])
        cor = self.get_corners()
        src_pts = np.array(cor)
        projection = AffineTransform()
        projection.estimate(dst_pts, src_pts)
        mask = rasterio.features.geometry_mask(shapes, [self.raster_height, self.raster_width],
                                               projection.params.flatten()[:-3])
        self.raster_data[np.invert(mask)] = pixel_value
        self.set_changed()

    def plot(self):
        plt_imshow(self.data)

    def to_file(self, file_path: Union[str, Path], target_crs: CRS = None):
        poly = self.get_polygon(target_crs=target_crs)
        save_np_array_as_geotiff(self.raster_data, self, file_path)